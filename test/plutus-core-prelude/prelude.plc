(module Prelude (imported) (exported () ()) (local () ())

  (define id
    (lam x x))

  (define const
    (lam x (lam y x)))

  (define flip
    (lam f (lam x (lam y
      [[f y] x]))))

  (define applyTo
    (lam x (lam f
      [f x])))

  (define compose
    (lam f (lam g (lam x
      [f [g x]]))))

  (define compose2
    (lam f (lam g (lam x (lam y
      [f [[g x] y]])))))

  (define fst
    (lam p
      (case p
        (cl Foo.MkPair (x y) x))))

  (define snd
    (lam p
      (case p
        (cl Foo.MkPair (x y) y))))

  (define curry
    (lam f (lam x (lam y
      [f (con Foo.MkPair x y)]))))

  (define uncurry
    (lam f (lam p
      (case p
        (cl Foo.MkPair (x y) [[f x] y])))))

  (define swap
    (lam p
      (case p
        (cl Foo.MkPair (x y) (con Foo.MkPair y x)))))

  (define and
    (lam x (lam y
      (case x
        (cl Bool.True () y)
        (cl Bool.False () (con Bool.False))))))

  (define or
    (lam x (lam y
      (case x
        (cl Bool.True () (con Bool.True))
        (cl Bool.False () x)))))

  (define not
    (lam x
      (case x
        (cl Bool.True () (con Bool.False))
        (cl Bool.False () (con Bool.True)))))

  (define bool
    (lam f (lam t (lam b
      (case b
        (cl Prelude.True  () t)
        (cl Prelude.False () f))))))

  (define lessThanEqualsInt (lam x (lam y [not (builtin lessThanInt y x)])))

  (define maxInt
    (lam x (lam y
      (case (builtin lessThanInt x y)
        (cl Prelude.True () y)
        (cl Prelude.False () x)))))

  (define minInt
    (lam x (lam y
      (case (builtin lessThanInt x y)
        (cl Prelude.True () x)
        (cl Prelude.False () y)))))

  (define lessThanEqualsFloat
    (lam x (lam y
      [Prelude.not (builtin lessThanFloat y x)])))

  (define maxFloat
    (lam x (lam y
      (case (builtin lessThanFloat x y)
        (cl Prelude.True () y)
        (cl Prelude.False () x)))))

  (define minFloat
    (lam x (lam y
      (case (builtin lessThanFloat x y)
        (cl Prelude.True () x)
        (cl Prelude.False () y)))))


  (define append
    (lam xs (lam ys
      (case xs
        (cl Prelude.Nil () ys)
        (cl Prelude.Cons (x xs') (con Prelude.Cons x [[Prelude.append xs'] ys]))))))

  (define head
    (lam xs
      (case xs
        (cl Prelude.Nil () (con Prelude.Nothing))
        (cl Prelude.Cons (x xs') (con Prelude.Just x)))))

  (define last
    (lam xs
      (case xs
        (cl Prelude.Nil () (con Prelude.Nothing))
        (cl Prelude.Cons (x xs')
              (case xs'
                (cl Prelude.Nil () (con Prelude.Just x))
                (cl Prelude.Cons (x' xs'') [last (con Prelude.Cons x' xs'')]))))))

  (define tail
    (lam xs
      (case xs
        (cl Prelude.Nil () (con Prelude.Nothing))
        (cl Prelude.Cons (x xs) (con Prelude.Just xs)))))

  (define init
    (lam xs
      (case xs
        (cl Prelude.Nil () (con Prelude.Nothing))
        (cl Prelude.Cons (x xs)
          (case [init xs]
            (cl Prelude.Nothing () (con Prelude.Nil))
            (cl Prelude.Just (ys) (con Prelude.Just (con Prelude.Cons x ys))))))))

  (define uncons
    (lam xs
      (case xs
        (cl Prelude.Nil () (con Prelude.Nothing))
        (cl Prelude.Cons (x xs) (con Prelude.Just (con Prelude.MkPair x xs))))))

  (define null
    (lam xs
      (case xs
        (cl Prelude.Nil () (con Prelude.True))
        (cl Prelude.Cons (x xs) (con Prelude.False)))))

  (define length
    (lam xs
      (case xs
        (cl Prelude.Nil () 0)
        (cl Prelude.Cons (x xs) (builtin addInt 1 [Prelude.length xs])))))

  (define take
    (lam n (lam xs
      (case (builtin equalsInt n 0)
        (cl Prelude.True () (con Prelude.Nil))
        (cl Prelude.False ()
          (case xs
            (cl Prelude.Nil () (con Prelude.Nil))
            (cl Prelude.Cons (x xs')
              (con Prelude.Cons x [[Prelude.take (builtin subtractInt n 1)] xs']))))))))

  (define drop
    (lam n (lam xs
      (case (builtin equalsInt n 0)
        (cl Prelude.True () xs)
        (cl Prelude.False ()
          (case xs
            (cl Prelude.Nil () (con Prelude.Nil))
            (cl Prelude.Cons (x xs')
              [[Prelude.drop (builtin subtractInt n 1)] xs'])))))))

)
